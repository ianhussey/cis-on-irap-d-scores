---
title: "Bootstrapped estimation of D scores for individual participants"
author: "Ian Hussey"
date: "`r format(Sys.time(), '%d %B %Y')`"
output:
  html_document:
    code_folding: hide
    highlight: haddock
    theme: flatly
    toc: yes
    toc_float: yes
---

# to do

- consider moving method to sensitivity analyses

# Overview 

IRAP trial-type *D* scores are calculated from an average of only 18 pairs of reaction times. This would be deemed as far too low anywhere else in the literature on reaction time based tasks. The implications of this can be seen in how poorly estimated any one IRAP D score is. We can observe this by bootstrapping reaction times for each participant's *D* scores and noting how wide their confidence intervals are.

```{r, include=FALSE}
knitr::opts_chunk$set(message=FALSE,
                      warning=FALSE,
                      cache.lazy=FALSE)
```

```{r}

# dependencies
library(tidyverse)
library(knitr)
library(kableExtra)
library(rsample)
library(broom)
library(purrr)
library(furrr)
library(pim)
library(boot)
library(parallel)
library(bayestestR)
library(afex)
library(lsmeans)
library(patchwork)
library(mdthemes)
library(lme4)
library(sjPlot)
library(emmeans)

# set seed for reproducibility
set.seed(42)

# number of bootstraps
n_boots <- 2000 

# run furrr:::future_map in parallel
plan(multiprocess)

# options
options(knitr.table.format = "html") # necessary configuration of tables

# disable scientific notation
options(scipen = 999) 


# function to round all numeric vars in a data frame
round_df <- function(df, n_digits = 3) {
  df %>% mutate_if(is.numeric, round, digits = n_digits)
}


# get data from evaluative IRAPs
data_trial_level <- read_csv("../data/data_trial_level.csv") %>%
  filter(timepoint == "baseline")

# outliers
data_outliers <- data_trial_level %>%
  distinct(unique_id, .keep_all = TRUE) %>%
  select(unique_id, domain, mean_rt) %>%
  mutate(median_mean_rt = median(mean_rt, na.rm = TRUE),
         mad_mean_rt = mad(mean_rt, na.rm = TRUE)) %>%
  # exclude median +- 2MAD
  mutate(rt_outlier = ifelse(mean_rt < median_mean_rt-mad_mean_rt*2 |
                               mean_rt > median_mean_rt+mad_mean_rt*2, TRUE, FALSE)) %>%
  filter(rt_outlier == FALSE) %>%
  select(unique_id, rt_outlier) %>%
  full_join(data_trial_level, by = "unique_id") %>%
  mutate(rt_outlier = ifelse(is.na(rt_outlier), TRUE, rt_outlier))

data_outliers_removed <- data_outliers %>%
  filter(rt_outlier == FALSE)

# trim RTs>10000 ms, as part of D scoring
data_trimmed <- data_outliers_removed %>%
  select(unique_id, domain, trial_type, rt, block_type) %>%
  filter(rt <= 10000)

# for plot
dodge_width <- 0.25

```

# Descriptives

```{r}

data_outliers %>%
  distinct(unique_id, .keep_all = TRUE) %>%
  count(rt_outlier) %>%
  kable() %>%
  kable_styling(bootstrap_options = c("striped", "hover", "condensed"), full_width = FALSE)

data_descriptives <- data_outliers_removed %>%
  distinct(unique_id, .keep_all = TRUE)

data_descriptives %>%
  count(domain) %>%
  kable() %>%
  kable_styling(bootstrap_options = c("striped", "hover", "condensed"), full_width = FALSE)

data_descriptives %>%
  count(domain) %>%
  summarize(total_n = sum(n),
            min_n_per_domain = min(n),
            max_n_per_domain = max(n),
            mean_n_per_domain = round(mean(n, na.rm = TRUE), 2),
            sd_n_per_domain = round(sd(n, na.rm = TRUE), 2)) %>%
  kable() %>%
  kable_styling(bootstrap_options = c("striped", "hover", "condensed"), full_width = FALSE)

data_descriptives %>%
  summarize(min_age = round(min(age, na.rm = TRUE), 2),
            max_age = round(max(age, na.rm = TRUE), 2),
            mean_age = round(mean(age, na.rm = TRUE), 2),
            sd_age = round(sd(age, na.rm = TRUE), 2)) %>%
  kable() %>%
  kable_styling(bootstrap_options = c("striped", "hover", "condensed"), full_width = FALSE)

data_descriptives %>%
  count(gender) %>%
  kable() %>%
  kable_styling(bootstrap_options = c("striped", "hover", "condensed"), full_width = FALSE)

```

# Distribution of RTs

```{r}

ggplot(data_trimmed, aes(rt, fill = block_type)) +
  geom_density(alpha = 0.3) +
  facet_wrap(~ trial_type)

data_trimmed %>%
  group_by(trial_type, block_type) %>%
  summarize(mean = mean(rt, na.rm = TRUE),
            sd = sd(rt, na.rm = TRUE)) %>%
  round_df(0) %>%
  kable() %>%
  kable_styling(bootstrap_options = c("striped", "hover", "condensed"), full_width = FALSE)

```

# Bootstrap 95% CIs on D scores

## *D* scores calculated by trial-type

```{r}

# bootstrapping has a long execution time, so load saved values if they've already been calculated
if(file.exists("models/data_estimates_D.rds")) {
  
  data_estimates_D <- read_rds("models/data_estimates_D.rds")
  
} else {
  
  D_score <- function(data, i) {
    data_with_indexes <- data[i,] # boot function requires data and index
    mean_con <- mean(data_with_indexes$rt[data_with_indexes$block_type == "con"], na.rm = TRUE)
    mean_incon <- mean(data_with_indexes$rt[data_with_indexes$block_type == "incon"], na.rm = TRUE)
    sd <- sd(data_with_indexes$rt, na.rm = TRUE)
    D <- (mean_incon - mean_con) / sd
    return(D)
  }
  
  bootstrap_D_score <- function(data){
    
    require(dplyr)
    require(boot)
    
    fit <- 
      boot::boot(data      = data, 
                 statistic = D_score, 
                 R         = n_boots, 
                 sim       = "ordinary", 
                 stype     = "i",
                 parallel  = "multicore", 
                 ncpus     = parallel::detectCores())
    
    results <- boot::boot.ci(fit, conf = 0.95, type = c("norm","basic", "perc", "bca"))
    
    output <- 
      tibble(method   = c("normal", "basic", "percent", "bca"),
             estimate = rep(fit$t0, 4),
             ci_lower = c(results$normal[2], results$basic[4], results$percent[4], results$bca[4]),
             ci_upper = c(results$normal[3], results$basic[5], results$percent[5], results$bca[5]))
    
    return(output)
  }
  
  # bootstrap D scores 
  data_estimates_D <- data_trimmed %>%
    select(unique_id, domain, trial_type, rt, block_type) %>%
    group_by(unique_id, domain, trial_type) %>%
    do(bootstrap_D_score(data = .)) %>%
    ungroup() %>%
    mutate(sig = ifelse((ci_lower < 0 & ci_upper < 0) | (ci_lower > 0 & ci_upper > 0), TRUE, FALSE),
           ci_width = ci_upper - ci_lower) %>%
    round_df(3)
  
  # save to disk
  write_rds(data_estimates_D, "models/data_estimates_D.rds", compress = "gz")
  
}

```

## PI scores calculated by trial-type

```{r}

# bootstrapping has a long execution time, so load saved values if they've already been calculated
if(file.exists("models/data_estimates_PI.rds")) {
  
  data_estimates_PI <- read_rds("models/data_estimates_PI.rds")
  
} else {
  
  # Fast calculation of the A statistic - code from Ruscio (2008) supplementary materials
  PI_score <- function(data, i) {
    data_with_indexes <- data[i,] # boot function requires data and index
    x  <- na.omit(data_with_indexes$rt[data_with_indexes$block_type == "incon"])
    y  <- na.omit(data_with_indexes$rt[data_with_indexes$block_type == "con"])
    nx <- length(x)
    ny <- length(y)
    rx <- sum(rank(c(x, y))[1:nx])
    PI <- (rx / nx - (nx + 1) / 2) / ny
    return(PI)
  }
  
  bootstrap_PI_score <- function(data){
    
    require(dplyr)
    require(boot)
    
    fit <- 
      boot::boot(data      = data, 
                 statistic = PI_score, 
                 R         = n_boots, 
                 sim       = "ordinary", 
                 stype     = "i",
                 parallel  = "multicore", 
                 ncpus     = parallel::detectCores())
    
    results <- boot::boot.ci(fit, conf = 0.95, type = c("norm","basic", "perc", "bca"))
    
    output <- 
      tibble(method   = c("normal", "basic", "percent", "bca"),
             estimate = rep(fit$t0, 4),
             ci_lower = c(results$normal[2], results$basic[4], results$percent[4], results$bca[4]),
             ci_upper = c(results$normal[3], results$basic[5], results$percent[5], results$bca[5]))
    
    return(output)
  }
  
  # bootstrap PI scores 
  data_estimates_PI <- data_outliers_removed %>%
    group_by(unique_id, domain, trial_type) %>%
    do(bootstrap_PI_score(data = .)) %>%
    ungroup() %>%
    mutate(sig = ifelse((ci_lower < 0.50 & ci_upper < 0.50) | (ci_lower > 0.50 & ci_upper > 0.50), TRUE, FALSE),
           ci_width = ci_upper - ci_lower) %>%
    round_df(3)

  # save to disk
  write_rds(data_estimates_PI, "models/data_estimates_PI.rds", compress = "gz")
  
}

```

## Point biserial correlations

```{r fig.height=15, fig.width=7}

library(broom)

data_estimates_rpb <- data_trimmed %>%
  select(unique_id, domain, trial_type, rt, block_type) %>%
  filter(rt <= 10000) %>%
  mutate(block_type = case_when(block_type == "con" ~ 0,
                                block_type == "incon" ~ 1)) %>%
  group_by(unique_id, domain, trial_type) %>%
  do(tidy(cor.test(formula = ~ block_type + rt, 
                   data = ., 
                   method = "pearson", 
                   conf.level = 0.95))) %>%
  ungroup() %>%
  mutate(sig = ifelse(p.value < .05, TRUE, FALSE)) %>%
  select(unique_id, domain, trial_type, estimate, ci_lower = conf.low, ci_upper = conf.high, sig) %>%
  mutate(ci_width = ci_upper - ci_lower) %>%
  mutate(method = "Arithmethic") %>%
  round_df(3)

# data_estimates_rpb %>%
#   arrange(estimate) %>%
#   group_by(domain) %>%
#   mutate(ordered_id = row_number()/n()) %>%
#   ungroup() %>%
#   ggplot() +
#   geom_linerange(aes(x = ordered_id, ymin = ci_lower, ymax = ci_upper, color = sig),
#                  alpha = 1) +
#   geom_point(aes(ordered_id, estimate), size = 0.5) +
#   geom_hline(yintercept = 0, linetype = "dotted") +
#   mdthemes::md_theme_linedraw() +
#   theme(axis.text.x = element_blank(),
#         axis.ticks.x = element_blank(),
#         legend.position = "top") +
#   scale_color_viridis_d(end = 0.6, direction = -1) +
#   xlab("Participant (ranked by rpb)") +
#   ylab("IRAP rpb") +
#   labs(color = "95% CI excludes zero") + 
#   facet_wrap(~ domain, ncol = 4)

```

# CI widths

Widths cant be directly compared between *D* and PI as they have different ranges, so *D* scores only.

Not meta analyzed as extreme skew in data means that residuals are very non-normal, violating assumptions and underestimating MAP estimates. Instead I simply present MAP estimates for each trial type & method, and then domain, trial type, and method.

## Descriptives

```{r fig.height=16, fig.width=16}

full_join(data_estimates_D %>%
            mutate(method = fct_relevel(method, "bca", "basic", "normal", "percent")) %>%
            group_by(method) %>%
            do(point_estimate(.$ci_width, centrality = "MAP")),
          data_estimates_D %>%
            mutate(method = fct_relevel(method, "bca", "basic", "normal", "percent")) %>%
            group_by(method) %>%
            summarize(min = min(ci_width),
                      max = max(ci_width),
                      .groups = "drop"),
          by = "method") %>%
  round_df(2) %>%
  kable() %>%
  kable_styling(bootstrap_options = c("striped", "hover", "condensed"), full_width = FALSE)

data_estimates_D %>%
  mutate(method = fct_relevel(method, "bca", "basic", "normal", "percent")) %>%
  group_by(trial_type, method) %>%
  do(point_estimate(.$ci_width, centrality = "MAP")) %>%
  round_df(2) %>%
  pivot_wider(names_from = method, values_from = MAP) %>%
  kable() %>%
  kable_styling(bootstrap_options = c("striped", "hover", "condensed"), full_width = FALSE)

data_estimates_D %>%
  mutate(method = fct_relevel(method, "bca", "basic", "normal", "percent")) %>%
  summarize(min_Dscore = min(estimate),
            max_Dscore = max(estimate)) %>%
  mutate(range_Dscore = max_Dscore - min_Dscore) %>% 
  round_df(2) 

```

## Plot by domain

```{r fig.height=8, fig.width=12}

data_ci_width_map_D <- data_estimates_D %>%
  group_by(domain, trial_type, method) %>%
  #summarize(median = median(ci_width), .groups = "drop") %>%
  do(point_estimate(.$ci_width, centrality = "MAP")) %>%
  ungroup() %>%
  mutate(method = fct_relevel(method, "bca", "basic", "normal", "percent"),
         trial_type = case_when(trial_type == "tt1" ~ "Trial type 1",
                                trial_type == "tt2" ~ "Trial type 2",
                                trial_type == "tt3" ~ "Trial type 3",
                                trial_type == "tt4" ~ "Trial type 4"),
         trial_type = fct_relevel(trial_type, "Trial type 1", "Trial type 2", "Trial type 3", "Trial type 4")) %>%
  mutate(domain = fct_reorder(domain, MAP, .fun = min)) %>%
  arrange(domain)

ggplot(data_ci_width_map_D, aes(MAP, domain, color = method, shape = method)) + 
  geom_line() +
  geom_point(position = position_dodge(width = 1)) +
  scale_shape_manual(labels = c("BCA", "Basic", "Normal", "Percentile"), values = c(15, 16, 17, 7)) +
  scale_color_viridis_d(begin = 0.2, end = 0.8, labels = c("BCA", "Basic", "Normal", "Percentile")) +
  mdthemes::md_theme_linedraw() +
  facet_wrap(~ trial_type, ncol = 4, nrow = 1) +
  labs(x = "MAP 95% CI width",
       y = "Domain",
       color = "Bootstrap method",
       shape = "Bootstrap method") + 
  theme(legend.position = "top")

```

# Proportion different from zero

## By bootstrapping method

Data is split by domain and method but this is not shown in the plot. All domains are collated, and only the BCA method is plotted.

```{r fig.height=6, fig.width=7}

p_dist_method <- data_estimates_D %>%
  mutate(method = fct_relevel(method, "bca", "basic", "normal", "percent")) %>%
  arrange(estimate) %>%
  group_by(method) %>%
  mutate(ordered_id = row_number()/n()) %>%
  ungroup() %>%
  ggplot() +
  geom_linerange(aes(x = ordered_id, ymin = ci_lower, ymax = ci_upper, color = sig),
                 alpha = 1) +
  geom_point(aes(ordered_id, estimate), size = 0.5) +
  geom_hline(yintercept = 0, linetype = "dotted") +
  mdthemes::md_theme_linedraw() +
  theme(axis.text.x = element_blank(),
        axis.ticks.x = element_blank(),
        legend.position = "top") +
  scale_color_viridis_d(end = 0.6, direction = -1) +
  xlab("Participant") +
  ylab("*D* score") +
  labs(color = "95% CI excludes zero point") + 
  facet_wrap(~ method)

p_dist_method

```

## By trial type

Data is split by domain and method but this is not shown in the plot. All domains are collated, and only the BCA method is plotted.

```{r fig.height=10, fig.width=7}

p_dist_D <- data_estimates_D %>%
  filter(method == "bca") %>%
  arrange(estimate) %>%
  group_by(trial_type) %>%
  mutate(ordered_id = row_number()/n()) %>%
  ungroup() %>%
  mutate(trial_type = case_when(trial_type == "tt1" ~ "TT1",
                                trial_type == "tt2" ~ "TT2",
                                trial_type == "tt3" ~ "TT3",
                                trial_type == "tt4" ~ "TT4"),
         trial_type = fct_relevel(trial_type, "TT1", "TT2", "TT3", "TT4")) %>%
  ggplot() +
  geom_linerange(aes(x = ordered_id, ymin = ci_lower, ymax = ci_upper, color = sig),
                 alpha = 1) +
  geom_point(aes(ordered_id, estimate), size = 0.5) +
  geom_hline(yintercept = 0, linetype = "dotted") +
  mdthemes::md_theme_linedraw() +
  theme(axis.text.x = element_blank(),
        axis.ticks.x = element_blank(),
        legend.position = "top") +
  scale_color_viridis_d(end = 0.6, direction = -1) +
  xlab("Participant") +
  ylab("*D* score") +
  labs(color = "95% CI excludes zero point") + 
  facet_wrap(~ trial_type)

p_dist_PI <- data_estimates_PI %>%
  filter(method == "bca") %>%
  arrange(estimate) %>%
  group_by(trial_type) %>%
  mutate(ordered_id = row_number()/n()) %>%
  ungroup() %>%
  mutate(trial_type = case_when(trial_type == "tt1" ~ "TT1",
                                trial_type == "tt2" ~ "TT2",
                                trial_type == "tt3" ~ "TT3",
                                trial_type == "tt4" ~ "TT4"),
         trial_type = fct_relevel(trial_type, "TT1", "TT2", "TT3", "TT4")) %>%
  ggplot() +
  geom_linerange(aes(x = ordered_id, ymin = ci_lower, ymax = ci_upper, color = sig),
                 alpha = 1) +
  geom_point(aes(ordered_id, estimate), size = 0.5) +
  geom_hline(yintercept = 0.50, linetype = "dotted") +
  mdthemes::md_theme_linedraw() +
  theme(axis.text.x = element_blank(),
        axis.ticks.x = element_blank(),
        legend.position = "top") +
  scale_color_viridis_d(end = 0.6, direction = -1) +
  xlab("Participant") +
  ylab("PI score") +
  labs(color = "95% CI excludes zero point") + 
  facet_wrap(~ trial_type)

p_dist_D + p_dist_PI + plot_layout(ncol = 1, nrow = 2)  # , guides = "collect"

```

## By domain

```{r fig.height=15, fig.width=7}

data_estimates_D %>%
  filter(method == "bca") %>%
  arrange(estimate) %>%
  group_by(domain) %>%
  mutate(ordered_id = row_number()/n()) %>%
  ungroup() %>%
  ggplot() +
  geom_linerange(aes(x = ordered_id, ymin = ci_lower, ymax = ci_upper, color = sig),
                 alpha = 1) +
  geom_point(aes(ordered_id, estimate), size = 0.5) +
  geom_hline(yintercept = 0, linetype = "dotted") +
  mdthemes::md_theme_linedraw() +
  theme(axis.text.x = element_blank(),
        axis.ticks.x = element_blank(),
        legend.position = "top") +
  scale_color_viridis_d(end = 0.6, direction = -1) +
  xlab("Participant (ranked by *D* score)") +
  ylab("IRAP D score") +
  labs(color = "95% CI excludes zero") + 
  facet_wrap(~ domain, ncol = 4)

```

## Table

32X35 cells

```{r}

# combine
data_diff_zero <- 
  bind_rows(mutate(data_estimates_D, DV_type = "*D* scores"),
            mutate(data_estimates_PI, DV_type = "PI scores")) %>%
    mutate(domain = as.factor(domain),
           method = fct_relevel(method, "bca", "basic", "normal", "percent"),
           trial_type = fct_relevel(trial_type, "tt1", "tt2", "tt3", "tt4")) %>%
  group_by(domain, trial_type, method, DV_type) %>%
  summarize(proportion_diff_zero = mean(sig),
            variance = plotrix::std.error(sig)^2,
            .groups = "drop") %>%
  mutate(variance = ifelse(variance == 0, 0.000001, variance))  # model cannot be run on zero variance, so offset

# table
data_diff_zero %>%
  filter(method == "bca") %>%
  mutate(DV_type = case_when(DV_type == "*D* scores" ~ "D",
                             DV_type == "PI scores" ~ "PI")) %>%
  select(-variance) %>%
  pivot_wider(names_from = c(trial_type, DV_type, method),
              values_from = proportion_diff_zero) %>%
  round_df(2) %>%
  janitor::clean_names() %>%
  kable() %>%
  kable_styling(bootstrap_options = c("striped", "hover", "condensed"), full_width = FALSE)

```

## Plot

```{r}

library(ggstance)

data_diff_zero %>%
  filter(method == "bca") %>%
  mutate(domain = fct_reorder(domain, proportion_diff_zero, .fun = mean)) %>%
  ggplot(aes(proportion_diff_zero, domain, color = DV_type, shape = DV_type)) +
  geom_linerangeh(aes(xmin = proportion_diff_zero - sqrt(variance)*1.96,
                      xmax = proportion_diff_zero + sqrt(variance)*1.96),
                  position = position_dodge(width = 1)) + 
  geom_point(position = position_dodge(width = 1)) +
  #scale_shape_manual(labels = c("BCA", "Basic", "Normal", "Percentile"), values = c(15, 16, 17, 7)) +
  #scale_color_viridis_d(begin = 0.2, end = 0.8, labels = c("BCA", "Basic", "Normal", "Percentile")) +
  mdthemes::md_theme_linedraw() +
  facet_wrap(~ trial_type, ncol = 4) +
  labs(x = "Proportion of scores different from zero",
       y = "Domain",
       color = "Scoring method",
       shape = "Scoring method") + 
  theme(legend.position = "top")

```

## Model

```{r}

# fit model
fit_diff_zero <- 
  lmer(proportion_diff_zero ~ 1 + trial_type * method * DV_type + (1 | domain),
       weights = 1/variance, 
       data = data_diff_zero)

# results table
tab_model(fit_diff_zero, 
          string.p = "p (corrected)", 
          ci.hyphen = ", ",
          #emph.p = FALSE,
          p.adjust = "holm")

plot_model(fit_diff_zero, 
           type = "re")

# extract marginal means
results_emm_diff_zero <- 
  summary(emmeans(fit_diff_zero, ~ DV_type | trial_type + method)) %>%
  select(DV_type, trial_type, method, estimate = emmean, ci_lower = lower.CL, ci_upper = upper.CL) %>%
  mutate(method = fct_relevel(method, "bca", "basic", "normal", "percent"),
         trial_type = fct_relevel(trial_type, "tt1", "tt2", "tt3", "tt4"))
  
p_diff_zero <- 
  ggplot(results_emm_diff_zero, aes(trial_type, estimate, color = method, shape = method, group = method)) +
  geom_linerange(aes(ymin = ci_lower, ymax = ci_upper), position = position_dodge(width = dodge_width)) +
  geom_line(position = position_dodge(width = dodge_width)) +
  geom_point(position = position_dodge(width = dodge_width), size = 2.5) +
  facet_wrap(~ DV_type, ncol = 1, nrow = 2) +
  scale_shape_discrete(labels = c("BCA", "Basic", "Normal", "Percentile")) +
  scale_color_viridis_d(end = 0.8, labels = c("BCA", "Basic", "Normal", "Percentile")) +
  mdthemes::md_theme_linedraw() +
  scale_x_discrete(labels = c("tt1" = "1", "tt2" = "2", "tt3" = "3", "tt4" = "4")) +
  labs(x = "Trial type",
       y = "Proportion of non-zero scores",
       color = "Bootstrap method",
       shape = "Bootstrap method") + 
  theme(legend.position = "top")

p_diff_zero

```

### domain

```{r}

# fit model
fit_diff_zero <- 
  data_diff_zero %>%
  filter(method == "bca") %>%
  lmer(proportion_diff_zero ~ 1 + trial_type * DV_type + (trial_type | domain),
       weights = 1/variance, 
       data = .)

# results table
tab_model(fit_diff_zero, 
          string.p = "p (corrected)", 
          ci.hyphen = ", ",
          #emph.p = FALSE,
          p.adjust = "holm")

plot_model(fit_diff_zero, 
           colors = "bw",
           type = "re") +
  mdthemes::md_theme_linedraw() +
  ggtitle("")

summary(fit_diff_zero)

# extract marginal means
results_emm_diff_zero <- 
  summary(emmeans(fit_diff_zero, ~ DV_type | trial_type)) %>%
  select(DV_type, trial_type, estimate = emmean, ci_lower = lower.CL, ci_upper = upper.CL) %>%
  mutate(trial_type = fct_relevel(trial_type, "tt1", "tt2", "tt3", "tt4"))
  
p_diff_zero <- 
  ggplot(results_emm_diff_zero, aes(trial_type, estimate, color = DV_type, shape = DV_type, group = DV_type)) +
  geom_linerange(aes(ymin = ci_lower, ymax = ci_upper), position = position_dodge(width = dodge_width)) +
  geom_line(position = position_dodge(width = dodge_width)) +
  geom_point(position = position_dodge(width = dodge_width), size = 2.5) +
  mdthemes::md_theme_linedraw() +
  scale_x_discrete(labels = c("tt1" = "1", "tt2" = "2", "tt3" = "3", "tt4" = "4")) +
  labs(x = "Trial type",
       y = "Proportion of non-zero scores") + 
  theme(legend.position = "top")

p_diff_zero

# tests
emmeans(fit_diff_zero, list(pairwise ~ DV_type | trial_type), adjust = "bonferroni")
emmeans(fit_diff_zero, list(pairwise ~ trial_type | DV_type), adjust = "bonferroni")

```

### domain glm

```{r}

# fit model
fit_diff_zero <- 
  bind_rows(mutate(data_estimates_D, DV_type = "*D* scores"),
            mutate(data_estimates_PI, DV_type = "PI scores")) %>%
    filter(method == "bca") %>%
    mutate(domain = as.factor(domain),
           trial_type = fct_relevel(trial_type, "tt1", "tt2", "tt3", "tt4")) %>%
  glmer(sig ~ 1 + trial_type * DV_type + (1 | domain),
        family = binomial(link = "logit"),
        data = .)

# results table
tab_model(fit_diff_zero, 
          string.p = "p (corrected)", 
          ci.hyphen = ", ",
          #emph.p = FALSE,
          p.adjust = "holm")

plot_model(fit_diff_zero, 
           colors = "bw",
           type = "re") +
  mdthemes::md_theme_linedraw() +
  ggtitle("")

summary(fit_diff_zero)

# extract marginal means
results_emm_diff_zero <- 
  summary(emmeans(fit_diff_zero, ~ DV_type | trial_type)) %>%
  select(DV_type, trial_type, estimate = emmean, ci_lower = asymp.LCL, ci_upper = asymp.UCL) %>%
  mutate(trial_type = fct_relevel(trial_type, "tt1", "tt2", "tt3", "tt4")) %>%
  mutate_if(is.numeric, exp)
  
p_diff_zero <- 
  ggplot(results_emm_diff_zero, aes(trial_type, estimate, color = DV_type, shape = DV_type, group = DV_type)) +
  geom_linerange(aes(ymin = ci_lower, ymax = ci_upper), position = position_dodge(width = dodge_width)) +
  geom_line(position = position_dodge(width = dodge_width)) +
  geom_point(position = position_dodge(width = dodge_width), size = 2.5) +
  mdthemes::md_theme_linedraw() +
  scale_x_discrete(labels = c("tt1" = "1", "tt2" = "2", "tt3" = "3", "tt4" = "4")) +
  labs(x = "Trial type",
       y = "Proportion of non-zero scores") + 
  theme(legend.position = "top")

p_diff_zero

# tests
emmeans(fit_diff_zero, list(pairwise ~ DV_type | trial_type), adjust = "bonferroni")
emmeans(fit_diff_zero, list(pairwise ~ trial_type | DV_type), adjust = "bonferroni")

```

# Proportion different from one another

Within domain and trial type

## Calculate discriminability

Many have argued that the zero point is arbitrary and not a useful reference point. Instead of asking "what proportion of *D*/PI scores are different from zero?", we could also ask "what proportion of *D*/PI scores are different from one another?"

### *D* scores

```{r}

# bootstrapping has a long execution time, so load saved values if they've already been calculated
if(file.exists("models/data_discriminability_D.rds")) {
  
  data_discriminability_D <- read_rds("models/data_discriminability_D.rds")
  
} else {
  
  # helper function to apply workflow to each resample
  discriminability <- function(data, i) {
    
    data_with_indexes <- data[i,] # boot function requires data and index
    
    estimate <- data_with_indexes$estimate
    ci_lower <- data_with_indexes$ci_lower
    ci_upper <- data_with_indexes$ci_upper
    
    n_estimate <- length(estimate)
    n_ci_lower <- length(ci_lower)
    n_ci_upper <- length(ci_upper)
    
    r_estimate <- sum(rank(c(estimate, ci_lower))[1:n_estimate])
    r_ci_upper <- sum(rank(c(ci_upper, estimate))[1:n_ci_upper])
    
    prob_estimate_inferior_to_ci_lower <- 1 - (r_estimate / n_estimate - (n_estimate + 1) / 2) / n_ci_lower
    prob_estimate_superior_to_ci_upper <- 1 - (r_ci_upper / n_ci_upper - (n_ci_upper + 1) / 2) / n_estimate
    
    probability_estimates_outside_cis <- (prob_estimate_inferior_to_ci_lower + prob_estimate_superior_to_ci_upper)
    
    return(probability_estimates_outside_cis)
    
  }
  
  bootstrap_discriminability <- function(data){
    
    require(dplyr)
    require(boot)
    
    fit <- 
      boot::boot(data      = data, 
                 statistic = discriminability, 
                 R         = n_boots,
                 sim       = "ordinary", 
                 stype     = "i",
                 parallel  = "multicore", 
                 ncpus     = parallel::detectCores())
    
    results <- boot::boot.ci(fit, conf = 0.95, type = c("norm","basic", "perc", "bca"))
    
    output <- 
      tibble(method   = c("normal", "basic", "percent", "bca"),
             estimate = rep(fit$t0, 4),
             ci_lower = c(results$normal[2], results$basic[4], results$percent[4], results$bca[4]),
             ci_upper = c(results$normal[3], results$basic[5], results$percent[5], results$bca[5]))
    
    return(output)
  }

  # bootstrap D scores 
  data_discriminability_D <- data_estimates_D %>%
    select(unique_id, domain, trial_type, estimate, ci_upper, ci_lower) %>%
    group_by(domain, trial_type) %>%
    do(bootstrap_discriminability(data = .)) %>%
    ungroup() %>%
    mutate(proportion_discriminable = estimate,
           variance = ((ci_upper - ci_lower)/(1.96*2))^2) %>%
    mutate(domain = as.factor(domain),
           method = fct_relevel(method, "bca", "basic", "normal", "percent"),
           trial_type = fct_relevel(trial_type, "tt1", "tt2", "tt3", "tt4"),
           DV_type = "*D* scores")
  
  # save to disk
  write_rds(data_discriminability_D, "models/data_discriminability_D.rds", compress = "gz")
  
}

```

### PI scores

```{r}

# bootstrapping has a long execution time, so load saved values if they've already been calculated
if(file.exists("models/data_discriminability_PI.rds")) {
  
  data_discriminability_PI <- read_rds("models/data_discriminability_PI.rds")
  
} else {
  
  # bootstrap D scores 
  data_discriminability_PI <- data_estimates_PI %>%
    select(unique_id, domain, trial_type, estimate, ci_upper, ci_lower) %>%
    group_by(domain, trial_type) %>%
    do(bootstrap_discriminability(data = .)) %>%
    ungroup() %>%
    mutate(proportion_discriminable = estimate,
           variance = ((ci_upper - ci_lower)/(1.96*2))^2) %>%
    mutate(domain = as.factor(domain),
           method = fct_relevel(method, "bca", "basic", "normal", "percent"),
           trial_type = fct_relevel(trial_type, "tt1", "tt2", "tt3", "tt4"),
           DV_type = "PI scores")
  
  # save to disk
  write_rds(data_discriminability_PI, "models/data_discriminability_PI.rds", compress = "gz")
  
}

```

## Model

```{r}

# combine
data_discriminability_combined <- 
  bind_rows(data_discriminability_D,
            data_discriminability_PI)

# fit meta analytic model
fit_disciminability <- 
  lmer(proportion_discriminable ~ 1 + trial_type * method * DV_type + (1 | domain), 
       weights = 1/variance, 
       data = data_discriminability_combined)

# results table
tab_model(fit_disciminability, 
          string.p = "p (corrected)", 
          ci.hyphen = ", ",
          #emph.p = FALSE,
          p.adjust = "holm")

# extract marginal means
results_emm_disciminability <- 
  summary(emmeans(fit_disciminability, ~ DV_type | trial_type + method)) %>%
  select(DV_type, trial_type, method, estimate = emmean, ci_lower = lower.CL, ci_upper = upper.CL) %>%
  mutate(method = fct_relevel(method, "bca", "basic", "normal", "percent"),
         trial_type = fct_relevel(trial_type, "tt1", "tt2", "tt3", "tt4"))
  
p_disciminability <- 
  ggplot(results_emm_disciminability, aes(trial_type, estimate, color = method, shape = method, group = method)) +
  geom_linerange(aes(ymin = ci_lower, ymax = ci_upper), position = position_dodge(width = dodge_width)) +
  geom_line(position = position_dodge(width = dodge_width)) +
  geom_point(position = position_dodge(width = dodge_width), size = 2.5) +
  facet_wrap(~ DV_type, ncol = 1, nrow = 2) +
  scale_shape_discrete(labels = c("BCA", "Basic", "Normal", "Percentile")) +
  scale_color_viridis_d(end = 0.8, labels = c("BCA", "Basic", "Normal", "Percentile")) +
  mdthemes::md_theme_linedraw() +
  scale_x_discrete(labels = c("tt1" = "1", "tt2" = "2", "tt3" = "3", "tt4" = "4")) +
  labs(x = "Trial type",
       y = "Proportion of discriminable scores",
       color = "Bootstrap method",
       shape = "Bootstrap method") + 
  theme(legend.position = "top")

p_disciminability

```

# CI widths as a proportion of observed range

## Calculate scores

```{r}

## calculate observed ranges 
observed_range_estimates_D <- data_estimates_D %>%
  group_by(domain, method, trial_type) %>%
  dplyr::summarize(min = min(estimate, na.rm = TRUE),
                   max = max(estimate, na.rm = TRUE),
                   .groups = "drop") %>%
  mutate(range = max - min) 

observed_range_estimates_PI <- data_estimates_PI %>%
  group_by(domain, method, trial_type) %>%
  dplyr::summarize(min = min(estimate, na.rm = TRUE),
                   max = max(estimate, na.rm = TRUE),
                   .groups = "drop") %>%
  mutate(range = max - min) 

observed_range_estimates_rpb <- data_estimates_rpb %>%
  group_by(domain, trial_type, method) %>%
  dplyr::summarize(min = min(estimate, na.rm = TRUE),
                   max = max(estimate, na.rm = TRUE),
                   .groups = "drop") %>%
  mutate(range = max - min) 



# calculate CI / range 
data_ci_width_proportions_D <- data_estimates_D %>%
  # join this data into the original data
  full_join(observed_range_estimates_D, by = c("domain", "method", "trial_type")) %>%
  # calculate ci width as a proportion of observed range
  mutate(ci_width_proportion = ci_width / range) %>%
  mutate(DV_type = "*D* scores") 

data_ci_width_proportions_PI <- data_estimates_PI %>%
  # join this data into the original data
  full_join(observed_range_estimates_PI, by = c("domain", "method", "trial_type")) %>%
  # calculate ci width as a proportion of observed range
  mutate(ci_width_proportion = ci_width / range) %>%
  mutate(DV_type = "PI scores")

data_ci_width_proportions_rpb <- data_estimates_rpb %>%
  # join this data into the original data
  full_join(observed_range_estimates_rpb, by = c("domain", "method", "trial_type")) %>%
  # calculate ci width as a proportion of observed range
  mutate(ci_width_proportion = ci_width / range) %>%
  mutate(DV_type = "*r*<sub>pb</sub> scores")

# combine
data_ci_width_proportions_combined <- 
  bind_rows(data_ci_width_proportions_D,
            data_ci_width_proportions_PI,
            data_ci_width_proportions_rpb) %>%
  mutate(domain = as.factor(domain),
         method = fct_relevel(method, "bca", "basic", "normal", "percent", "Arithmethic"),
         trial_type = fct_relevel(trial_type, "tt1", "tt2", "tt3", "tt4"))

```

## Compare scoring methods

```{r}

# fit model
fit_ci_width_proportions_scoring <- 
  data_ci_width_proportions_combined %>%
  filter(method == "bca" & DV_type %in% c("*D* scores", "PI scores")) %>%
  lmer(ci_width_proportion ~ trial_type * DV_type + (1 | domain) + (1 | unique_id), 
       data = .)


# results table
tab_model(fit_ci_width_proportions_scoring,
          string.p = "p (corrected)",
          ci.hyphen = ", ",
          #emph.p = FALSE,
          p.adjust = "holm")

# extract marginal means
results_emm_ci_width_proportions_scoring <-
  summary(emmeans(fit_ci_width_proportions_scoring, ~ DV_type | trial_type)) %>%
  select(DV_type, trial_type, estimate = emmean, ci_lower = asymp.LCL, ci_upper = asymp.UCL) %>%
  mutate(DV_type = fct_relevel(DV_type, "*D* scores", "*r*<sub>pb</sub> scores", "PI scores"),
         trial_type = fct_relevel(trial_type, "tt1", "tt2", "tt3", "tt4"))


dodge_width <- 0.15

p_ci_width_proportions_scoring <-
  ggplot(results_emm_ci_width_proportions_scoring, aes(trial_type, estimate, color = DV_type, shape = DV_type, group = DV_type)) +
  geom_linerange(aes(ymin = ci_lower, ymax = ci_upper), position = position_dodge(width = dodge_width)) +
  geom_line(position = position_dodge(width = dodge_width)) +
  geom_point(position = position_dodge(width = dodge_width), size = 2.5) +
  scale_shape_discrete(labels = c("*D* scores", "PI scores")) +
  scale_color_viridis_d(begin = 0.3, end = 0.7, labels = c("*D* scores", "PI scores")) +
  mdthemes::md_theme_linedraw() +
  scale_x_discrete(labels = c("tt1" = "1", "tt2" = "2", "tt3" = "3", "tt4" = "4")) +
  labs(x = "Trial type",
       y = "95% CI width / observed range",
       color = "Scoring method",
       shape = "Scoring method") +
  theme(legend.position = "top")

p_ci_width_proportions_scoring

# tests
emmeans(fit_ci_width_proportions_scoring, list(pairwise ~ DV_type | trial_type), adjust = "bonferroni")
emmeans(fit_ci_width_proportions_scoring, list(pairwise ~ trial_type | DV_type), adjust = "bonferroni")

```

## Compare CI methods

```{r}

data_ci_width_proportions_combined_method <- 
  bind_rows(data_ci_width_proportions_D,
            data_ci_width_proportions_rpb) %>%
  mutate(domain = as.factor(domain),
         method = as.factor(method),
         method = fct_relevel(method, "bca", "basic", "normal", "percent", "Arithmethic"),
         trial_type = fct_relevel(trial_type, "tt1", "tt2", "tt3", "tt4")) %>%
  select(unique_id, domain, trial_type, method, ci_width_proportion) 

# fit model

if(file.exists("models/fit_ci_width_proportions_method.rds")) {
  
  fit_ci_width_proportions_method <- read_rds("models/fit_ci_width_proportions_method.rds")

} else {
  
  fit_ci_width_proportions_method <- 
    lmer(ci_width_proportion ~ trial_type * method + (1 | domain/unique_id), 
         data = data_ci_width_proportions_combined_method)
  
  write_rds(fit_ci_width_proportions_method, "models/fit_ci_width_proportions_method.rds")
  
}
  
  
fit_ci_width_proportions_method <- 
  lmer(ci_width_proportion ~ trial_type * method + (1 | domain/unique_id), 
       data = data_ci_width_proportions_combined_method)

# results table
tab_model(fit_ci_width_proportions_method, 
          string.p = "p (corrected)", 
          ci.hyphen = ", ",
          #emph.p = FALSE,
          p.adjust = "holm")

# extract marginal means
results_emm_ci_width_proportions_method <- 
  summary(emmeans(fit_ci_width_proportions_method, ~ trial_type | method)) %>%
  select(method, trial_type, estimate = emmean, ci_lower = asymp.LCL, ci_upper = asymp.UCL) %>%
  mutate(method = fct_relevel(method, "bca", "basic", "normal", "percent", "Arithmethic"),
         trial_type = fct_relevel(trial_type, "tt1", "tt2", "tt3", "tt4"))
  
p_ci_width_proportions_method <- 
  ggplot(results_emm_ci_width_proportions_method, aes(trial_type, estimate, color = method, shape = method, group = method)) +
  geom_linerange(aes(ymin = ci_lower, ymax = ci_upper), position = position_dodge(width = dodge_width)) +
  geom_line(position = position_dodge(width = dodge_width)) +
  geom_point(position = position_dodge(width = dodge_width), size = 2.5) +
  scale_shape_discrete(labels = c("*D* score (BCA bootstrap)", 
                                  "*D* score (basic bootstrap)", 
                                  "*D* score (normal bootstrap)", 
                                  "*D* score (percentile bootstrap)",
                                  "*r*<sub>pb</sub> (arithmethic)")) +
  scale_color_viridis_d(end = 0.8, labels = c("*D* score (BCA bootstrap)", 
                                              "*D* score (basic bootstrap)", 
                                              "*D* score (normal bootstrap)", 
                                              "*D* score (percentile bootstrap)",
                                              "*r*<sub>pb</sub> (arithmethic)")) +
  mdthemes::md_theme_linedraw() +
  scale_x_discrete(labels = c("tt1" = "1", "tt2" = "2", "tt3" = "3", "tt4" = "4")) +
  labs(x = "Trial type",
       y = "95% CI width / observed range",
       color = "Confidence Interval method",
       shape = "Confidence Interval method") + 
  theme(legend.position = "right")

p_ci_width_proportions_method

# tests
emmeans(fit_ci_width_proportions_method, list(pairwise ~ method | trial_type), adjust = "bonferroni")

```

# Session info

```{r}

sessionInfo()

```
